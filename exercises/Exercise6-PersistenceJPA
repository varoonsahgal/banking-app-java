# Adding Persistence to Our Banking Application

Thus far, we have a functional banking application. Now, what if we want to persist the results of a single banking transaction in a database?

Let's explore that.

## Goal

Using the Port concept from Hexagonal Architecture, we'll create an interface to define how the information will be sent to the external service.

## Create a Port - an Interface

Create a new interface that will define our ideal way to communicate with the external service. Add the following interface to the `com.example.domain.port` package - create the package if it does not exist:

```java
public interface TransactionMonitor {
  void transactionCompleted(User user, Transaction transaction);
}
```

An implementation will be passed into the User class, so modify its constructor to accept a TransactionMonitor reference. Since we already have a constructor that takes a parameter, we'll create a two-argument constructor.

```java
// add to User.java
private TransactionMonitor transactionMonitor;

public User(Username username, TransactionMonitor transactionMonitor) {
  // assign Username & TransactionMonitor to private fields
}
```

## Food For Thought

First, a question: would you want to modify the domain classes to persist data? Perhaps we could add an @Entity annotation to one of our domain classes? Think about why or why not...

The answer is no, we would not want to do that, because then we would be essentially making our domain classes "impure", and they would only be able to be used by our web adapter and not our console adapter (and that includes any future adapters).

So, how would we persist data while retaining the purity of our domain classes?

Essentially, this is what we are trying to accomplish at a high level - where persistence/databases are considered "infrastructure":


## Back to Work - Testing using a Mockito Spy

Create a new test class, TransactionMonitorTest, and add these import statements:

```java
// use these static imports in the test class 
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
```

Then you'll write several tests to validate that the transactionCompleted method gets called when a transaction is completed with different scenarios.

To write a test, create a spy and inject it into the User as in the test below:


```java
@Test
public void depositTransactionIsCompletedAndResultsSentToMonitor() throws Exception {
    // create the spy based on the interface
    TransactionMonitor transactionMonitorSpy = spy(TransactionMonitor.class);
    // TODO: finish the rest of this setup...
    User user = new User(new Username("testuser"), transactionMonitorSpy);
    user.deposit(100);  

    // verify that the transactionCompleted method was called with any instance of User and Transaction classes
    verify(transactionMonitorSpy).transactionCompleted(any(User.class), any(Transaction.class));
}


```

Fill in the code for the TODO with the appropriate scenario, watch the test fail, and then modify the User code to make it pass.

The three test scenarios to cover are as follows:

1. A deposit transaction is completed, and the results are sent to the Transaction Monitor.
2. A withdrawal transaction is completed, and the results are sent to the Transaction Monitor.
3. A negative test where the user attempts to withdraw an amount greater than the balance: no call is made to the transactionCompleted method. Use the never() verification as follows:

```java
verify(transactionMonitorSpy, never()).transactionCompleted(any(User.class), any(Transaction.class));
```

## Creating a Concrete TransactionMonitor Implementation
1. Create an entity class called TransactionEntity in a subpackage called adapter.out.transactionmonitor - utilize the JPA entity annotation, and add the dependency. This will represent your table. You will want an id as before and have it be autogenerated. Then, define fields for username, transactionType, amount, and balance. These should all be of type String.

2. Create a DTO class named TransactionResultDto (in the adapter.out.transactionmonitor sub-package) that matches the above data format (all values are Strings). The DTO can look like this:

```java
public class TransactionResultDto {
    private final String username;
    private final String transactionType;
    private final String amount;
    private final String balance;

    public TransactionResultDto(String username, String transactionType, String amount, String balance) {
        this.username = username;
        this.transactionType = transactionType;
        this.amount = amount;
        this.balance = balance;
    }

    // Generate getter methods for the above fields
}
```

3. Add a static method named from that takes a User and Transaction parameter and translates the information, storing the result in the fields. This is similar to the GameView (in the Web Adapter) where the of(Game) method translates the Game into a GameView DTO.

4. Create an interface that extends a Spring Data JPA repository interface, like JpaRepository:

```java
package com.example.adapter.out.transactionmonitor;

import org.springframework.data.jpa.repository.JpaRepository;

public interface TransactionResultRepository extends JpaRepository<TransactionEntity, Long> {
}

```

Note that Spring Boot, through Spring Data JPA, automatically detects this interface during the component scan and provides the necessary implementation utilizing our H2 database whenever you instantiate an object of type TransactionResultRepository.

So, we will use H2 as our in-memory database as we have done before, so be sure to provide the same settings that we have used in the past in your application.properties file as well. Spring will autodetect and wire up the H2 database based on those settings for you.

The generated implementation includes all the CRUD methods defined in JpaRepository, such as save(), findById(), findAll(), deleteById(), and more. This is KEY, so you don't have to implement this stuff yourself and write SQL! Amazing, right?

5. Then, provide an implementation of the TransactionMonitor class that implements transactionCompleted and invokes the methods that JPA gives you for free:

```java
public class PersistTransactionMonitor implements TransactionMonitor {

    private final TransactionResultRepository transactionResultRepository;

    public PersistTransactionMonitor(TransactionResultRepository transactionResultRepository) {
        this.transactionResultRepository = transactionResultRepository;
    }

    @Override
    public void transactionCompleted(User user, Transaction transaction) {
        TransactionResultDto dto = TransactionResultDto.from(user, transaction);
        TransactionEntity entity = new TransactionEntity(dto);
        transactionResultRepository.save(entity);
    }
}
```

The transactionCompleted method should convert the incoming User and Transaction parameters to a DTO. Then, you will want to send that DTO to the database utilizing the methods that JPA gives you.

6. Change the createUser method in the BankingApplication so that an instance of your PersistTransactionMonitor is passed into the User's constructor.


# Summary

To summarize, here are the key elements that we are using and why:

1. DTO (Data Transfer Object): This will represent the data structure used to transfer data between the layers of the application. In our case, our DTO will have the details of the transaction outcome - so something like this:

```java
public class TransactionResultDto {
    private final String username;
    private final String transactionType;
    private final String amount;
    private final String balance;

    // Constructor and getters
}
```

The DTO should live outside the domain, in an adapter package. So, put it in an adapter.out.transactionmonitor subpackage.

2. Port: An interface that defines the operations related to persisting and retrieving data. It will reside in the domain layer.

3. Adapter: The implementation of the port. This uses JPA to persist and retrieve data. It will reside in the infrastructure layer outside of our domain.




