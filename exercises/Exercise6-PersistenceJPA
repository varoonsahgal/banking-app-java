# Adding Persistence to Our Banking Application

Thus far, we have a functional banking application. Now, what if we want to persist the results of a single banking transaction in a database?

Let's explore that.

## Goal

Using the Port concept from Hexagonal Architecture, we'll create an interface to define how the information will be sent to the external service.

## Create a Port - an Interface

Create a new interface that will define our ideal way to communicate with the external service. Add the following interface to the `com.example.domain.port` package - create the package if it does not exist:

```java
public interface TransactionMonitor {
  void transactionCompleted(User user, Transaction transaction);
}
```

An implementation will be passed into the User class, so modify its constructor to accept a TransactionMonitor reference. Since we already have a constructor that takes a parameter, we'll create a two-argument constructor.

```java
// add to User.java
private TransactionMonitor transactionMonitor;

public User(Username username, TransactionMonitor transactionMonitor) {
  // assign Username & TransactionMonitor to private fields
}
```

## Food For Thought

First, a question: would you want to modify the domain classes to persist data? Perhaps we could add an @Entity annotation to one of our domain classes? Think about why or why not...

The answer is no, we would not want to do that, because then we would be essentially making our domain classes "impure", and they would only be able to be used by our web adapter and not our console adapter (and that includes any future adapters).

So, how would we persist data while retaining the purity of our domain classes?

Essentially, this is what we are trying to accomplish at a high level - where persistence/databases are considered "infrastructure":


## Back to Work - Testing using a Mockito Spy

Create a new test class, TransactionMonitorTest, and add these import statements:

```java
// use these static imports in the test class 
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
```

Then you'll write several tests to validate that the transactionCompleted method gets called when a transaction is completed with different scenarios.

To write a test, create a spy and inject it into the User as in the test below:


```java
@Test
public void depositTransactionIsCompletedAndResultsSentToMonitor() throws Exception {
    // create the spy based on the interface
    TransactionMonitor transactionMonitorSpy = spy(TransactionMonitor.class);
    // TODO: finish the rest of this setup...
    User user = new User(new Username("testuser"), transactionMonitorSpy);
    user.deposit(100);  

    // verify that the transactionCompleted method was called with any instance of User and Transaction classes
    verify(transactionMonitorSpy).transactionCompleted(any(User.class), any(Transaction.class));
}


```

Fill in the code for the TODO with the appropriate scenario, watch the test fail, and then modify the User code to make it pass.

The three test scenarios to cover are as follows:

1. A deposit transaction is completed, and the results are sent to the Transaction Monitor.
2. A withdrawal transaction is completed, and the results are sent to the Transaction Monitor.
3. A negative test where the user attempts to withdraw an amount greater than the balance: no call is made to the transactionCompleted method. Use the never() verification as follows:

```java
verify(transactionMonitorSpy, never()).transactionCompleted(any(User.class), any(Transaction.class));
```

## Creating a Concrete TransactionMonitor Implementation
1. Create an entity class called TransactionEntity in a subpackage called adapter.out.transactionmonitor - utilize the JPA entity annotation, and add the dependency. This will represent your table. You will want an id as before and have it be autogenerated. Then, define fields for username, transactionType, amount, and balance. These should all be of type String.

2. Create a DTO class named TransactionResultDto (in the adapter.out.transactionmonitor sub-package) that matches the above data format (all values are Strings). The DTO can look like this:

```java
public class TransactionResultDto {
    private final String username;
    private final String transactionType;
    private final String amount;
    private final String balance;

    public TransactionResultDto(String username, String transactionType, String amount, String balance) {
        this.username = username;
        this.transactionType = transactionType;
        this.amount = amount;
        this.balance = balance;
    }

    // Generate getter methods for the above fields
}


```







